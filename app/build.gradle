apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'


def releaseTime() {
    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC+8"))
}

android {
    /**
     * 如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion
     * 用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。
     * minSdkVersion <= targetSdkVersion <= compileSdkVersion
     *      1:minSdkVersion 和 targetSdkVersion 与 compileSdkVersion 的另一个不同之处是它们会被包含进最终的 APK 文件中，
     * 如果你查看生成的 AndroidManifest.xml 文件，你会看到类似下面这样的标签：
     * http://www.open-open.com/lib/view/open1453253049558.html
     */
    signingConfigs {
        config {
            keyAlias 'yuerbao_keystore'
            keyPassword '123456'
            storeFile file('E:/temp/MyApplication/app/KeyStore.jks')
            storePassword '123456'
        }
    }
    compileSdkVersion rootProject.compileSdkVersion    //compileSdkVersion 设置为可用的最新 API
    buildToolsVersion rootProject.buildToolsVersion
    /**
     * defaultConfig 是所有构建变体的基础，也是设置这些默认值的地方。
     * 你可以想象在一个更复杂的系统中，应用的某些版本可能会有不同的 minSdkVersion 。
     */
    defaultConfig {
        applicationId "com.gxy.application"
        minSdkVersion rootProject.minSdkVersion
        targetSdkVersion rootProject.targetSdkVersion
        versionCode 1
        multiDexEnabled true
        versionName "1.0"
        /*
        use AndroidJUnitRunner进行单元测试
         */
        testInstrumentationRunner 'android.support.test.runner.AndroidJUnitRunner'
    }
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.config
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    //生成指定名称的apk文件
    android.applicationVariants.all { variant ->
        variant.outputs.each { output ->
            def outputFile = output.outputFile
            if (outputFile != null && outputFile.name.endsWith('.apk')) {
                //这里修改apk文件名
                def fileName = "${releaseTime()}_" +
                        "${variant.buildType.name}.apk";
                if (variant.productFlavors.size() > 0) {
                    fileName = "${variant.productFlavors[0].name}_" +
                            "v${variant.productFlavors[0].versionName}_" +
                            "${releaseTime()}_" +
                            "${variant.buildType.name}.apk";
                }
                output.outputFile = new File(outputFile.parent, fileName)
            }
        }
    }

    //多渠道打包
    productFlavors {
    }
    //解决编译器的内存设置不足问题
    dexOptions {
//        incremental true
        javaMaxHeapSize "4g"
    }

    sourceSets {
        main.java.srcDirs += 'src/main/kotlin'
        test.java.srcDirs += 'src/test/kotlin'
    }

    testOptions {
        unitTests.returnDefaultValues = true
    }
}

repositories {
    flatDir {
        dirs 'libs' //就是你放aar的目录地址
    }
    mavenCentral()
}
dependencies {
    compile 'com.android.support:support-v4:'.concat(rootProject.supportLibVersion);
    compile 'com.android.support:appcompat-v7:'.concat(rootProject.supportLibVersion);
    compile 'com.android.support:design:'.concat(rootProject.supportLibVersion);
    compile 'com.android.support:recyclerview-v7:'.concat(rootProject.supportLibVersion);
    compile "com.android.support:cardview-v7:$rootProject.supportLibVersion"
    compile "org.jetbrains.kotlin:kotlin-stdlib:1.1.1"
    compile "org.jetbrains.kotlin:kotlin-reflect:1.1.1"
    compile 'org.jetbrains.anko:anko-sdk15:0.9'
    compile 'org.jetbrains.anko:anko-support-v4:0.9'
    compile 'org.jetbrains.anko:anko-appcompat-v7:0.9'

    //测试框架
    testCompile "junit:junit:$rootProject.junitVersion"
    testCompile "org.mockito:mockito-core:$rootProject.mockitoVersion"
    testCompile "org.jetbrains.kotlin:kotlin-test-junit:1.1.1"
    //    testInstrumentationRunner
    compile "com.android.support.test.espresso:espresso-idling-resource:$rootProject.espressoVersion"
    androidTestCompile "com.android.support.test:runner:$rootProject.runnerVersion"
    androidTestCompile "com.android.support.test:rules:$rootProject.rulesVersion"
//    // Resolve conflicts between main and test APK:
    androidTestCompile "com.android.support:support-annotations:$rootProject.supportLibVersion"
//
    androidTestCompile "com.android.support.test.espresso:espresso-core:$rootProject.espressoVersion"
    androidTestCompile "com.android.support.test.espresso:espresso-intents:$rootProject.espressoVersion"
    androidTestCompile("com.android.support.test.espresso:espresso-contrib:$rootProject.espressoVersion") {
        exclude module: 'recyclerview-v7'
        exclude module: 'design'
    }

    androidTestCompile "com.android.support:recyclerview-v7:$rootProject.supportLibVersion"
    androidTestCompile "junit:junit:$rootProject.junitVersion"
}
/*
Resolves dependency versions across test and production APKs, specifically, transitive
dependencies. This is required since Espresso internally has a dependency on support-annotations.
*/
configurations.all {
    resolutionStrategy.force "com.android.support:support-annotations:$rootProject.supportLibVersion"
}

/*
All direct/transitive dependencies shared between your test and production APKs need to be
excluded from the test APK! This is necessary because both APKs will contain the same classes. Not
excluding these dependencies from your test configuration will result in an dex pre-verifier error
at runtime. More info in this tools bug: (https://code.google.com/p/android/issues/detail?id=192497)
*/
configurations.compile.dependencies.each { compileDependency ->
    println "Excluding compile dependency: ${compileDependency.getName()}"
    configurations.androidTestCompile.dependencies.each { androidTestCompileDependency ->
        configurations.androidTestCompile.exclude module: "${compileDependency.getName()}"
    }
}